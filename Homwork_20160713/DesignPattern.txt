DesignPattern(設計模式)

	

	1.CREATIONAL PATTERNS(生成模式):在討論物件的建立程序，使系統能動態地決定物件的建立，及如何有效率地建立、組成及管理這些物件。

		
		i.Singleton(單例模式):在某些時候，為了管控資源或是避免多個物件分享相同資源，在同一時間，某個類別只會存在一個唯一的物件，可用此法。

		
		
		ex.一個國家的領袖只能有一個，
		
		當國家需要審核某些重要提案時，

		必須經過領袖這一流程，
		
		這流程中不會有分支，
		也不允許新建領袖(class)
	
	
		
	ii.Factory(<簡單>工廠模式):工廠模式最主要的精神就是將 new Class 這個動作另外封裝成一個 Factory Class，這個Factory Class 專門負責實體化這些類別。

		
		
		ex.你進到一家西餐廳，

		店內有許多套餐，

		顧客可以選擇要何種套餐，

		不同套餐所需要製作的工法與材料皆不同

		
		
	iii.Factory Method(工廠方法模式):要解決簡單工廠模式的問題，工廠方法模式的做法是將 Factory 類別抽象化，讓每個 Product 子類別都有屬於自己的工廠類別。

		
	
		ex.如果西餐廳要開發新菜單，

		廚師必須要重新學習新的烹飪方式，

		這樣是較無效率且需要改變廚師本人的廚藝(類似改寫原程式碼)，

		而像麥當勞這類的速食店，

		如果現在有新菜單的話，

		只需要像該店送新材料(類似新建新的class)，

		裡面的工讀生不需要做其餘的動作，

		只需要拿出不同材料(class)即可

				
		
	iv.Prototype(原型模式):有些物件若以標準的方式建立實例，或者是設定至某個狀態需要複雜的運算及昂貴的資源，則您可以考慮直接以某個物件作為原型，在需要個別該物件時，複製原型並傳回。

		
ex.一套百科全書內容是非常多且厚重的，

		一位管理員每次有人來詢問資料時，

		都需要重新翻過書櫃才能找到該資料，非常麻煩，

		所以當他知道來向他詢問的人有外科醫師，國文老師和程式工程師的話，

		管理員可以先將人體醫學，文學及程式語言的相關內容先影印出來(clone)，

		收在自己身邊，當這些人有來詢問時，只需要找這些影印資料即可


	
2.STRUCTURAL PATTERNS(結構模式):在討論如何組合類別和物件成更大的結構。


	i.Decorator(裝飾模式):可以動態的為一個物件加上功能（責任），此方法提供一種有彈性的方法來解決，當透過繼承來新增物件的功能不實際，或會產生過多的物件時，可以使用 Decorator 來動態的新增物件功能。

		ex.一款遊戲可以選擇種族(人類、精靈、矮人、半獸人)，

		選擇完種族後可以選擇職業(劍士、弓手，法師，刺客、僧侶)，

		再因應你的種族與職業給予可使用的武器以及可學習的技能

		(像半獸人無法學習光屬性魔法，僧侶無法裝備弓等等)


	ii.Adapter(轉接器模式):Adapter Pattern的目的在於將類別的介面轉換成外界預期的另一種介面，讓原先因為介面不相容問題而無法協力合作的類別能夠兜在一起用。


		ex.一本英文書籍，如果不懂英文的人要閱讀的話，
		必須要有一個翻譯人員(adapter)來進行翻譯讓不懂英文的人能夠閱讀


	iii.Bridge(橋接模式):父類別只是一個抽象類別(abstract)或介面(interface)實作後的子類別，與父類別的功能是相同的，但每個功能可以有不同的展現屬於實作部分的擴增
	    
	    

		ex.兩地中有隔著一座高山阻擋著，
	    
		以前來往需要繞山路非常不方便，
	    
		現在有開個山洞(bridge)讓兩地可以更方便的互通
	    
	    

	iv.Facade(外觀模式):為子系統中的一組接口提供一個統一的高層接口，使得子系統更容易使用。
	    
	    
		
		ex.一個班級有風紀股長，學藝股長，衛生股長等，
	    
		老師每次有事情都要分別找人，
	    
		所以選出一個班長，
	    
		老師有事就只需要找班長，
	    
		班長再傳達給需要知道的人即可
	    
	

3.BEHAVIORAL PATTERNS(行為模式):旨在探討物件之間的行為互動及分配，良好的行為互動，使程式的執行更有效率，物件的調度更有彈性。
		
		

	i.Command(命令模式):其主要精神在於將指令的建立與執行分離
		
		

		ex.你到了一家主題樂園，該樂園裡有許多遊樂設施
		
		消費者需要先選擇要玩那些遊樂設施，
		
		選擇完後售票員會給一組票卡，
		
		消費者再依據所持票卡去那些遊樂區遊玩
		
		

	ii.Observer(觀察模式):定義了物件之間一對多關係，如此一來當一個物件改變狀態，其他相依者都會收到通知並自動更新。 
		
		

		ex.某連鎖店家有建立line群組，
		
		若觀察者選擇加入該line群組，
		
		即可收到該連鎖店家即時提供的優惠訊息
